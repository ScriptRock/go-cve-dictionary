package commands

import (
	"context"
	"errors"
	"fmt"
	"regexp"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var fetchNvdAsyncPostgresCmd = &cobra.Command{
	Use:   "nvd-async-postgres",
	Short: "Fetch Vulnerability dictionary from NVD without deleting the existing tables (postgres)",
	Long:  "Fetch Vulnerability dictionary from NVD without deleting the existing tables (postgres)",
	RunE:  fetchNvdAsyncPostgres,
}

func init() {
	fetchCmd.AddCommand(fetchNvdAsyncPostgresCmd)

	fetchNvdAsyncPostgresCmd.PersistentFlags().String("target-db-schema", "", "The postgres schema within which the tables/data should reside. This should match the schema specified in the go-cve-dictionary's server's dbpath connection string.")
	_ = viper.BindPFlag("target-db-schema", fetchNvdAsyncPostgresCmd.PersistentFlags().Lookup("target-db-schema"))
}

func fetchNvdAsyncPostgres(_ *cobra.Command, args []string) (err error) {
	targetDbSchema := viper.GetString("target-db-schema")
	if targetDbSchema == "" {
		return errors.New("target-db-schema is required")
	}

	if !isPostgresIdentifierValid(targetDbSchema) {
		return errors.New("target-db-schema is not a valid PostgreSQL identifier")
	}

	dbtype := viper.GetString("dbtype")
	if dbtype != "postgres" && dbtype != "" {
		return errors.New("dbtype must be left blank or set to \"postgres\"")
	}
	viper.Set("dbtype", dbtype)

	dbpath := viper.GetString("dbpath")

	if strings.Contains(dbpath, "csearch_path") {
		return errors.New("specifying \"csearch_path\" in dbpath will break go-cve-dictionary's migrations")
	}

	if strings.Contains(dbpath, "options") {
		return errors.New("specifying \"options\" in dbpath is not supported for this command")
	}

	conn, err := pgx.Connect(context.Background(), dbpath)
	if err != nil {
		return fmt.Errorf("connect to db: %w", err)
	}
	defer conn.Close(context.Background())

	if err := fetchNvd(nil, args); err != nil {
		return fmt.Errorf("fetch nvd: %w", err)
	}

	if err := swapSchemas(conn, targetDbSchema); err != nil {
		return fmt.Errorf("swap schemas: %w", err)
	}

	return nil
}

func swapSchemas(conn *pgx.Conn, targetDbSchema string) (err error) {
	tx, err := conn.BeginTx(context.Background(), pgx.TxOptions{})
	if err != nil {
		return fmt.Errorf("start tx: %w", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback(context.Background())
		} else {
			tx.Commit(context.Background())
		}
	}()

	// TODO does vulns user have correct priv to do these?
	// TODO do we need vulns to own new schema/altered schema?

	if _, err = tx.Exec(context.Background(), fmt.Sprintf("DROP SCHEMA IF EXISTS %s CASCADE", targetDbSchema)); err != nil {
		return fmt.Errorf("drop schema %s: %w", targetDbSchema, err)
	}

	if _, err = tx.Exec(context.Background(), fmt.Sprintf("ALTER SCHEMA public RENAME TO %s", targetDbSchema)); err != nil {
		return fmt.Errorf("rename schema public as %s: %w", targetDbSchema, err)
	}

	if _, err = tx.Exec(context.Background(), "CREATE SCHEMA public"); err != nil {
		return fmt.Errorf("create schema public: %w", err)
	}

	count := 0
	if err := conn.QueryRow(context.Background(), fmt.Sprintf("SELECT COUNT(*) FROM %s.nvds", targetDbSchema)).Scan(&count); err != nil {
		return fmt.Errorf("query nvds in %s: %w", targetDbSchema, err)
	}
	if count < 1 {
		return fmt.Errorf("no nvds in %s: %w", targetDbSchema, err)
	}

	return nil
}

func isPostgresIdentifierValid(v string) bool {
	return regexp.MustCompile(`([A-Za-z0-9\-\_]+)`).MatchString(v)
}
