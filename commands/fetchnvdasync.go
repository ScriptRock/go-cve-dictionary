package commands

import (
	"context"
	"errors"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var fetchNvdAsyncPostgresCmd = &cobra.Command{
	Use:   "nvd-async-postgres",
	Short: "Fetch Vulnerability dictionary from NVD without deleting the existing tables (postgres)",
	Long:  "Fetch Vulnerability dictionary from NVD without deleting the existing tables (postgres)",
	RunE:  fetchNvdAsyncPostgres,
}

func init() {
	fetchCmd.AddCommand(fetchNvdAsyncPostgresCmd)

	fetchNvdAsyncPostgresCmd.PersistentFlags().String("dst-db-schema", "", "The postgres schema within which the tables/data should reside. This should match the schema specified in the go-cve-dictionary's server's dbpath connection string.")
	_ = viper.BindPFlag("dst-db-schema", fetchNvdAsyncPostgresCmd.PersistentFlags().Lookup("dst-db-schema"))
}

func fetchNvdAsyncPostgres(_ *cobra.Command, args []string) (err error) {
	dstDbSchema := viper.GetString("dst-db-schema")
	if dstDbSchema == "" {
		return errors.New("dst-db-schema is required")
	}

	if !isPostgresIdentifierValid(dstDbSchema) {
		return errors.New("dst-db-schema is not a valid PostgreSQL identifier")
	}

	dbtype := viper.GetString("dbtype")
	if dbtype != "postgres" && dbtype != "" {
		return errors.New("dbtype must be left blank or set to \"postgres\"")
	}
	viper.Set("dbtype", "postgres")

	dbpath := viper.GetString("dbpath")
	dbConfig, err := pgx.ParseConfig(dbpath)
	if err != nil {
		return fmt.Errorf("parse db config: %w", err)
	}

	srcDbSchema := getDbRuntimeParamOptionsSearchPath(dbConfig)
	if srcDbSchema == "" {
		return errors.New("dbpath must contain csearch_path in runtime parameters with 1 schema specified")
	}

	ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*10)
	defer ctxCancel()

	conn, err := pgx.ConnectConfig(ctx, dbConfig)
	if err != nil {
		return fmt.Errorf("connect to db: %w", err)
	}
	defer func() {
		ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*10)
		defer ctxCancel()

		if err := conn.Close(ctx); err != nil {
			log.Printf("ERR failed to close connection: %s", err)
		}
	}()

	if _, err = conn.Exec(ctx, fmt.Sprintf("CREATE SCHEMA IF NOT EXISTS %s", srcDbSchema)); err != nil {
		return fmt.Errorf("create schema %s: %w", srcDbSchema, err)
	}

	if err := fetchNvd(nil, args); err != nil {
		return fmt.Errorf("fetch nvd: %w", err)
	}

	ctx, ctxCancel = context.WithTimeout(context.Background(), time.Second*120)
	defer ctxCancel()

	if err := swapSchemas(ctx, conn, srcDbSchema, dstDbSchema); err != nil {
		return fmt.Errorf("swap schemas: %w", err)
	}

	return nil
}

func getDbRuntimeParamOptionsSearchPath(c *pgx.ConnConfig) string {
	if c.RuntimeParams == nil {
		return ""
	}

	//"-c str=bgh,tre,pos search_path=cve_dictionary_sync blah=abc"
	options, ok := c.RuntimeParams["options"]
	if !ok {
		return ""
	}

	split := strings.Split(regexp.MustCompile(`search_path=([^\s]+)`).FindString(options), "=")

	if len(split) != 2 || split[0] != "search_path" || !isPostgresIdentifierValid(split[1]) {
		return ""
	}

	return split[1]
}

func swapSchemas(ctx context.Context, conn *pgx.Conn, srcDbSchema, dstDbSchema string) (err error) {
	tx, err := conn.BeginTx(ctx, pgx.TxOptions{})
	if err != nil {
		return fmt.Errorf("start tx: %w", err)
	}
	defer func() {
		if err != nil {
			if rollbackErr := tx.Rollback(ctx); err != nil {
				log.Printf("ERR Failed to rollback transaction: %s", rollbackErr)
			}
		}
	}()

	if _, err = tx.Exec(ctx, fmt.Sprintf("DROP SCHEMA IF EXISTS %s CASCADE", dstDbSchema)); err != nil {
		return fmt.Errorf("drop schema %s: %w", dstDbSchema, err)
	}

	if _, err = tx.Exec(ctx, fmt.Sprintf("ALTER SCHEMA %s RENAME TO %s", srcDbSchema, dstDbSchema)); err != nil {
		return fmt.Errorf("rename schema %s as %s: %w", srcDbSchema, dstDbSchema, err)
	}

	count := 0
	if err := conn.QueryRow(ctx, fmt.Sprintf("SELECT COUNT(*) FROM %s.nvds", dstDbSchema)).Scan(&count); err != nil {
		return fmt.Errorf("query nvds in %s: %w", dstDbSchema, err)
	}
	if count < 1 {
		return fmt.Errorf("no nvds in %s: %w", dstDbSchema, err)
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("commit tx: %w", err)
	}

	return nil
}

func isPostgresIdentifierValid(v string) bool {
	return regexp.MustCompile(`([A-Za-z0-9\-\_]+)`).MatchString(v)
}
