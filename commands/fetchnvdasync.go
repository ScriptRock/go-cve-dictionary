package commands

import (
	"context"
	"errors"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var fetchNvdAsyncPostgresCmd = &cobra.Command{
	Use:   "nvd-async-postgres",
	Short: "Fetch Vulnerability dictionary from NVD without deleting the existing tables (postgres)",
	Long:  "Fetch Vulnerability dictionary from NVD without deleting the existing tables (postgres)",
	RunE:  fetchNvdAsyncPostgres,
}

func init() {
	fetchCmd.AddCommand(fetchNvdAsyncPostgresCmd)

	fetchNvdAsyncPostgresCmd.PersistentFlags().String("target-db-schema", "", "The postgres schema within which the tables/data should reside. This should match the schema specified in the go-cve-dictionary's server's dbpath connection string.")
	_ = viper.BindPFlag("target-db-schema", fetchNvdAsyncPostgresCmd.PersistentFlags().Lookup("target-db-schema"))
}

func fetchNvdAsyncPostgres(_ *cobra.Command, args []string) (err error) {
	targetDbSchema := viper.GetString("target-db-schema")
	if targetDbSchema == "" {
		return errors.New("target-db-schema is required")
	}

	if !isPostgresIdentifierValid(targetDbSchema) {
		return errors.New("target-db-schema is not a valid PostgreSQL identifier")
	}

	dbtype := viper.GetString("dbtype")
	if dbtype != "postgres" && dbtype != "" {
		return errors.New("dbtype must be left blank or set to \"postgres\"")
	}
	viper.Set("dbtype", dbtype)

	dbpath := viper.GetString("dbpath")

	if strings.Contains(dbpath, "csearch_path") {
		return errors.New("specifying \"csearch_path\" in dbpath will break go-cve-dictionary's migrations")
	}

	if strings.Contains(dbpath, "options") {
		return errors.New("specifying \"options\" in dbpath is not supported for this command")
	}

	ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*10)
	defer ctxCancel()

	conn, err := pgx.Connect(ctx, dbpath)
	if err != nil {
		return fmt.Errorf("connect to db: %w", err)
	}
	defer func() {
		ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*10)
		defer ctxCancel()

		if err := conn.Close(ctx); err != nil {
			log.Printf("ERR failed to close connection: %s", err)
		}
	}()

	if err := fetchNvd(nil, args); err != nil {
		return fmt.Errorf("fetch nvd: %w", err)
	}

	ctx, ctxCancel = context.WithTimeout(context.Background(), time.Second*120)
	defer ctxCancel()

	if err := swapSchemas(ctx, conn, targetDbSchema); err != nil {
		return fmt.Errorf("swap schemas: %w", err)
	}

	return nil
}

func swapSchemas(ctx context.Context, conn *pgx.Conn, targetDbSchema string) (err error) {
	tx, err := conn.BeginTx(ctx, pgx.TxOptions{})
	if err != nil {
		return fmt.Errorf("start tx: %w", err)
	}
	defer func() {
		if err != nil {
			if rollbackErr := tx.Rollback(ctx); err != nil {
				log.Printf("ERR Failed to rollback transaction: %s", rollbackErr)
			}
		}
	}()

	if _, err = tx.Exec(ctx, fmt.Sprintf("DROP SCHEMA IF EXISTS %s CASCADE", targetDbSchema)); err != nil {
		return fmt.Errorf("drop schema %s: %w", targetDbSchema, err)
	}

	if _, err = tx.Exec(ctx, fmt.Sprintf("ALTER SCHEMA public RENAME TO %s", targetDbSchema)); err != nil {
		return fmt.Errorf("rename schema public as %s: %w", targetDbSchema, err)
	}

	if _, err = tx.Exec(ctx, "CREATE SCHEMA public"); err != nil {
		return fmt.Errorf("create schema public: %w", err)
	}

	count := 0
	if err := conn.QueryRow(ctx, fmt.Sprintf("SELECT COUNT(*) FROM %s.nvds", targetDbSchema)).Scan(&count); err != nil {
		return fmt.Errorf("query nvds in %s: %w", targetDbSchema, err)
	}
	if count < 1 {
		return fmt.Errorf("no nvds in %s: %w", targetDbSchema, err)
	}

	if err := tx.Commit(ctx); err != nil {
		return fmt.Errorf("commit tx: %w", err)
	}

	return nil
}

func isPostgresIdentifierValid(v string) bool {
	return regexp.MustCompile(`([A-Za-z0-9\-\_]+)`).MatchString(v)
}
