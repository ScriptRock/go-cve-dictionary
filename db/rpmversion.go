package db

import (
	"fmt"
	"regexp"
	"strings"
	"unicode"

	rpmver "github.com/knqyf263/go-rpm-version"
)

// alphanumPattern is the same as [rpmver.Version].
var alphanumPattern = regexp.MustCompile("([a-zA-Z]+)|([0-9]+)|(~)")

// rpmVersion wraps [rpmver.Version].
type rpmVersion struct {
	wrapped rpmver.Version
}

// newRpmVersion creates a [rpmVersion].
func newRpmVersion(ver string) (version rpmVersion) {
	version.wrapped = rpmver.NewVersion(ver)

	return version
}

// Equal implements [rpmver.Version.Equal].
func (v1 *rpmVersion) Equal(v2 rpmVersion) (bool, error) {
	if v1.wrapped.Compare(v2.wrapped) != 0 {
		return false, nil
	}

	if err := rpmSegmentsCmp(v1.wrapped.Version(), v2.wrapped.Version()); err != nil {
		return false, fmt.Errorf("compare version: %w", err)
	}

	if err := rpmSegmentsCmp(v1.wrapped.Release(), v2.wrapped.Release()); err != nil {
		return false, fmt.Errorf("release release: %w", err)
	}

	return true, nil
}

// LessThan implements [rpmver.Version.LessThan].
func (v1 rpmVersion) LessThan(v2 rpmVersion) (bool, error) {
	epochCmp := v1.withEpochOnly().wrapped.Compare(v2.withEpochOnly().wrapped)
	if epochCmp == -1 {
		return true, nil
	} else if epochCmp == 1 {
		return false, nil
	}

	versionCmp := v1.withVersionOnly().wrapped.Compare(v2.withVersionOnly().wrapped)
	if versionCmp != 0 {
		if err := rpmSegmentsCmp(v1.wrapped.Version(), v2.wrapped.Version()); err != nil {
			return false, fmt.Errorf("compare version: %w", err)
		}

		if versionCmp < 0 {
			return true, nil
		} else if versionCmp > 0 {
			return false, nil
		}
	}

	if err := rpmSegmentsCmp(v1.wrapped.Release(), v2.wrapped.Release()); err != nil {
		return false, fmt.Errorf("compare release: %w", err)
	}

	return v1.wrapped.Compare(v2.wrapped) < 0, nil
}

func (v rpmVersion) withEpochOnly() rpmVersion {
	wrapped := rpmver.NewVersion(fmt.Sprintf("%d:", v.wrapped.Epoch()))

	if wrapped.Epoch() != v.wrapped.Epoch() ||
		wrapped.Version() != "" ||
		wrapped.Release() != "" {
		panic(fmt.Sprintf("withEpochOnly failed on %d", v.wrapped.Epoch()))
	}

	return rpmVersion{
		wrapped: wrapped,
	}
}

func (v rpmVersion) withVersionOnly() rpmVersion {
	if strings.Contains(v.wrapped.Version(), "-") {
		panic(fmt.Sprintf("rpm version has a dash (%+v), this should not be possible.", v))
	}

	wrapped := rpmver.NewVersion(fmt.Sprintf(":%s", v.wrapped.Version()))

	if wrapped.Version() != v.wrapped.Version() ||
		wrapped.Epoch() != 0 ||
		wrapped.Release() != "" {
		panic(fmt.Sprintf("withVersionOnly failed on %s", v.wrapped.Version()))
	}

	return rpmVersion{
		wrapped: wrapped,
	}
}

// rpmSegmentsCmp ensures the rpm version or release have the same number of segments, the
// same type and same separators.
//
// This use of this function will lead to false negatives (for RPM version matching). We're
// willing to accept this at this stage.
func rpmSegmentsCmp(left, right string) error {
	if left == right {
		return nil
	}

	segsLeft := alphanumPattern.FindAllString(left, -1)
	segsRight := alphanumPattern.FindAllString(right, -1)

	if len(segsLeft) != len(segsRight) {
		return fmt.Errorf("segment length mistmatch between %v & %v", segsLeft, segsRight)
	}

	for i := 0; i < len(segsLeft); i++ {
		a := segsLeft[i]
		b := segsRight[i]

		isNumber := func(s []rune) bool {
			for a := range s {
				if !unicode.IsNumber(s[a]) {
					return false
				}
			}

			return true
		}

		if isNumber([]rune(a)) && !isNumber([]rune(b)) {
			return fmt.Errorf("segment a[%v] (%v) is a number but segment b[%v] (%v) is not", i, a, i, b)
		}

		if !isNumber([]rune(a)) && isNumber([]rune(b)) {
			return fmt.Errorf("segment b[%v] (%v) is not a number but segment b[%v] (%v) is", i, a, i, b)
		}
	}

	leftSeparators := left
	for a := 0; a < len(segsLeft); a++ {
		leftSeparators = strings.Replace(leftSeparators, segsLeft[a], "", 1)

	}

	rightSeparators := right
	for a := 0; a < len(segsRight); a++ {
		rightSeparators = strings.Replace(rightSeparators, segsRight[a], "", 1)
	}

	for _, left := range leftSeparators {
		match := false
		for _, right := range rightSeparators {
			if left == right {
				match = true
				break
			}
		}

		if !match {
			return fmt.Errorf("separator \"%v\" appears in left, but not right", left)
		}
	}

	for _, right := range rightSeparators {
		match := false
		for _, left := range leftSeparators {
			if left == right {
				match = true
				break
			}
		}

		if !match {
			return fmt.Errorf("separator \"%v\" appears in right, but not left", right)
		}
	}

	return nil
}
