package db

import (
	"fmt"
	"regexp"
	"strings"
	"unicode"

	rpmver "github.com/knqyf263/go-rpm-version"
)

// alphanumPattern is the same as [rpmver.Version].
var alphanumPattern = regexp.MustCompile("([a-zA-Z]+)|([0-9]+)|(~)")

// rpmVersion wraps [rpmver.Version]. Our wrapped [rpmVersion] exposes from [rpmver.Version]
// only the methods we need. We're wrapping [rpmver.Version] as it's comparison is a bit
// too forgiving for our use cases, so we make use of [rpmSegmentsCmp] to avoid false
// positives at the cost of more false negatives.
type rpmVersion struct {
	wrapped rpmver.Version
}

// newRpmVersion creates a [rpmVersion].
func newRpmVersion(ver string) (version rpmVersion) {
	version.wrapped = rpmver.NewVersion(ver)

	return version
}

// Equal implements [rpmver.Version.Equal]. This logic relies on the implementation of
// [rpm.Version.Compare] so it may be quite brittle. However, without writing our own
// RPM version comparison this may be the best approach.
func (v *rpmVersion) Equal(v2 rpmVersion) (bool, error) {
	cmp, err := v.compare(v2)
	if err != nil {
		return false, err
	}

	return cmp == 0, nil
}

// LessThan implements [rpmver.Version.LessThan]. This logic relies on the implementation of
// [rpm.Version.Compare] so it may be quite brittle. However, without writing our own
// RPM version comparison this may be the best approach.
func (v rpmVersion) LessThan(v2 rpmVersion) (bool, error) {
	cmp, err := v.compare(v2)
	if err != nil {
		return false, err
	}

	return cmp < 0, nil
}

func (v rpmVersion) compare(v2 rpmVersion) (int, error) {
	// [rpm.Version.Compare] first compares the epoch. If not equal, both the versions & releases are not compared.
	// So, we first rely on [rpm.Version.Compare] to test just the epochs (see [rpmVersion.withEpochOnly]). If not
	// equal, we can short circuit comparison here before having to apply our more strict [rpmSegmentsCmp] on the
	// versions or releases.
	epochCmp := v.withEpochOnly().wrapped.Compare(v2.withEpochOnly().wrapped)
	if epochCmp != 0 {
		return epochCmp, nil
	}

	// See the previous comment/epoch comparison. If the epochs of both v1 & v2 are equal, [rpm.Version.Compare]
	// next compares the versions. If not equal, the releases are not compared. So we can then next rely on
	// [rpm.Version.Compare] to test just the versions (see [rpmVersion.withVersionOnly]). If not equal, we can
	// short circuit comparison here before having to apply our more strict [rpmSegmentsCmp] on the
	// releases.
	if err := rpmSegmentsCmp(v.wrapped.Version(), v2.wrapped.Version()); err != nil {
		return 0, fmt.Errorf("compare version: %w", err)
	}

	versionCmp := v.withVersionOnly().wrapped.Compare(v2.withVersionOnly().wrapped)
	if versionCmp != 0 {
		return versionCmp, nil
	}

	// See the previous comments/epoch&version comparison. Finally, if the epochs & versions of v1 & v2 are equal,
	// [rpm.Version.Compare] next compares the releases. So we know we'll need to rely on [rpmSegmentsCmp] for the
	// releases.
	if err := rpmSegmentsCmp(v.wrapped.Release(), v2.wrapped.Release()); err != nil {
		return 0, fmt.Errorf("compare release: %w", err)
	}

	return v.wrapped.Compare(v2.wrapped), nil
}

// withEpochOnly returns a copy of v with the same epoch but no version or release.
func (v rpmVersion) withEpochOnly() rpmVersion {
	wrapped := rpmver.NewVersion(fmt.Sprintf("%d:", v.wrapped.Epoch()))

	if wrapped.Epoch() != v.wrapped.Epoch() ||
		wrapped.Version() != "" ||
		wrapped.Release() != "" {
		panic(fmt.Sprintf("withEpochOnly failed on %d", v.wrapped.Epoch()))
	}

	return rpmVersion{
		wrapped: wrapped,
	}
}

// withEpochOnly returns a copy of v with the same version but no epoch or release.
func (v rpmVersion) withVersionOnly() rpmVersion {
	if strings.Contains(v.wrapped.Version(), "-") {
		panic(fmt.Sprintf("rpm version has a dash (%+v), this should not be possible.", v))
	}

	wrapped := rpmver.NewVersion(fmt.Sprintf(":%s", v.wrapped.Version()))

	if wrapped.Version() != v.wrapped.Version() ||
		wrapped.Epoch() != 0 ||
		wrapped.Release() != "" {
		panic(fmt.Sprintf("withVersionOnly failed on %s", v.wrapped.Version()))
	}

	return rpmVersion{
		wrapped: wrapped,
	}
}

// rpmSegmentsCmp ensures the rpm version or release have the same number of segments, the
// same type and same separators.
//
// This use of this function will lead to false negatives (for RPM version matching). We're
// willing to accept this at this stage.
func rpmSegmentsCmp(left, right string) error {
	if left == right || left == "" || right == "" {
		return nil
	}

	segsLeft := alphanumPattern.FindAllString(left, -1)
	segsRight := alphanumPattern.FindAllString(right, -1)

	if len(segsLeft) != len(segsRight) {
		return fmt.Errorf("segment length mistmatch between %v & %v", segsLeft, segsRight)
	}

	for i := 0; i < len(segsLeft); i++ {
		a := segsLeft[i]
		b := segsRight[i]

		isNumber := func(s []rune) bool {
			for a := range s {
				if !unicode.IsNumber(s[a]) {
					return false
				}
			}

			return true
		}

		if isNumber([]rune(a)) && !isNumber([]rune(b)) {
			return fmt.Errorf("segment a[%v] (%v) is a number but segment b[%v] (%v) is not", i, a, i, b)
		}

		if !isNumber([]rune(a)) && isNumber([]rune(b)) {
			return fmt.Errorf("segment b[%v] (%v) is not a number but segment b[%v] (%v) is", i, a, i, b)
		}
	}

	leftSeparators := left
	for a := 0; a < len(segsLeft); a++ {
		leftSeparators = strings.Replace(leftSeparators, segsLeft[a], "", 1)
	}

	rightSeparators := right
	for a := 0; a < len(segsRight); a++ {
		rightSeparators = strings.Replace(rightSeparators, segsRight[a], "", 1)
	}

	for _, left := range leftSeparators {
		match := false
		for _, right := range rightSeparators {
			if left == right {
				match = true
				break
			}
		}

		if !match {
			return fmt.Errorf("separator \"%v\" appears in left, but not right", left)
		}
	}

	for _, right := range rightSeparators {
		match := false
		for _, left := range leftSeparators {
			if left == right {
				match = true
				break
			}
		}

		if !match {
			return fmt.Errorf("separator \"%v\" appears in right, but not left", right)
		}
	}

	return nil
}
