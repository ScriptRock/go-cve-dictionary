package db

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/hashicorp/go-version"
)

type versionParser func(string) (*version.Version, error)

var customParsers = map[string]versionParser{
	"openssl:openssl":                                 openSslVersionParser,
	"citrix:application_delivery_controller":          replaceDashParser,
	"citrix:application_delivery_controller_firmware": replaceDashParser,
	"citrix:application_delivery_management":          replaceDashParser,
	"citrix:gateway":                                  replaceDashParser,
	"citrix:gateway_firmware":                         replaceDashParser,
	"citrix:netscaler_gateway":                        replaceDashParser,
	"citrix:netscaler_gateway_firmware":               replaceDashParser,
}

var defaultParser = version.NewVersion

// RewriteVersion is a special function to rewrite versions that might not conform to SemVer
// into a SemVer compatible fashion (if needed) so that they can be used with hashicorp version parser
func RewriteVersion(vendor, product, version string) (string, error) {
	// first let's check if we require a custom parser for this product
	customParserKey := fmt.Sprintf("%s:%s", vendor, product)
	if customParser, ok := customParsers[customParserKey]; ok {
		if v, err := customParser(version); err != nil {
			return "", err
		} else {
			return v.String(), nil
		}
	}

	if v, err := defaultParser(version); err != nil {
		return "", err
	} else {
		return v.String(), nil
	}
}

var openSslVersionRegexp = regexp.MustCompile(`^(([0-9]+)\.([0-9]+)\.([0-9]+))([a-z])?$`)

// openSslVersionParser is a special parser for OpenSSL versions. OpenSSL used a special variant of semver
// in the form {MAJOR}.{MINOR}.{PATCH(letter)} (https://github.com/openssl/openssl/issues/5042#issuecomment-356264737)
// Specifically the letter in the patch number is interpreted by the hashicorp/go-version library as a pre-release
// when it shouldn't
func openSslVersionParser(v string) (*version.Version, error) {
	// we try to match the version string for OpenSSL and then will replace the letter
	// in the patch number with an extra numerical segment so that we can feed
	// it into hashicorp/go-version as another normal version
	matches := openSslVersionRegexp.FindStringSubmatch(v)
	if matches == nil {
		return nil, fmt.Errorf("Malformed OpenSSL version: %s", v)
	}
	segmentsStr := strings.Split(matches[1], ".")

	pre := int64(0)
	if matches[5] != "" {
		pre = patchLetterToNumber(rune(matches[5][0]))
	}

	// now that we parsed all the segments reconstruct the version string as a four segment version
	segmentsStr = append(segmentsStr, strconv.FormatInt(pre, 10))
	newVersion := strings.Join(segmentsStr, ".")

	return version.NewVersion(newVersion)
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyz")

func patchLetterToNumber(patchLetter rune) int64 {
	for i, r := range letterRunes {
		if r == patchLetter {
			return int64(i + 1)
		}
	}
	return 0
}

// replaceDashParser replaces dashes with dots
//
// The dash is interpreted as a pre-release separator in the hashicorp library,
// and a version constraint without a pre-release can never match a version with
// a pre-release. This means v15.1-rc1 does not match the constraint ">= v15", for
// example.
//
// This parser should be used when the dash in the version number is not a
// pre-release separator, and is equivalent to a dot separator. This is the case
// with Citrix version numbers e.g. 11.1-65.20 where 11.1 is the release
// version, and 65.20 is the build version.
func replaceDashParser(v string) (*version.Version, error) {
	newVersion := strings.Replace(v, "-", ".", 1)
	return version.NewVersion(newVersion)
}
