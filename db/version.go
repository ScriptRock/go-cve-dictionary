package db

import (
	"fmt"
	"github.com/hashicorp/go-version"
	"regexp"
	"strconv"
	"strings"
)

type versionParser func(string) (*version.Version, error)

var customParsers = map[string]versionParser{
	"openssl:openssl": openSslVersionParser,
}

var defaultParser = version.NewVersion

// RewriteVersion is a special function to rewrite versions that might not conform to SemVer
// into a SemVer compatible fashion (if needed) so that they can be used with hashicorp version parser
func RewriteVersion(vendor, product, version string) (string, error) {
	// first let's check if we require a custom parser for this product
	customParserKey := fmt.Sprintf("%s:%s", vendor, product)
	if customParser, ok := customParsers[customParserKey]; ok {
		if v, err := customParser(version); err != nil {
			return "", err
		} else {
			return v.String(), nil
		}
	}

	if v, err := defaultParser(version); err != nil {
		return "", err
	} else {
		return v.String(), nil
	}
}

var openSslVersionRegexp = regexp.MustCompile(`^(([0-9]+)\.([0-9]+)\.([0-9]+))([a-z])?$`)

// openSslVersionParser is a special parser for OpenSSL versions. OpenSSL used a special variant of semver
// in the form {MAJOR}.{MINOR}.{PATCH(letter)} (https://github.com/openssl/openssl/issues/5042#issuecomment-356264737)
// Specifically the letter in the patch number is interpreted by the hashicorp/go-version library as a pre-release
// when it shouldn't
func openSslVersionParser(v string) (*version.Version, error) {
	// we try to match the version string for OpenSSL and then will replace the letter
	// in the patch number with an extra numerical segment so that we can feed
	// it into hashicorp/go-version as another normal version
	matches := openSslVersionRegexp.FindStringSubmatch(v)
	if matches == nil {
		return nil, fmt.Errorf("Malformed OpenSSL version: %s", v)
	}
	segmentsStr := strings.Split(matches[1], ".")

	pre := int64(0)
	if matches[5] != "" {
		pre = patchLetterToNumber(rune(matches[5][0]))
	}

	// now that we parsed all the segments reconstruct the version string as a four segment version
	segmentsStr = append(segmentsStr, strconv.FormatInt(pre, 10))
	newVersion := strings.Join(segmentsStr, ".")

	return version.NewVersion(newVersion)
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyz")

func patchLetterToNumber(patchLetter rune) int64 {
	for i, r := range letterRunes {
		if r == patchLetter {
			return int64(i + 1)
		}
	}
	return 0
}
